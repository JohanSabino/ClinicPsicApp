# IE-GA7-220501096-AA2-EV01
## CODIFICACIÓN DE MÓDULOS DEL SOFTWARE SEGÚN REQUERIMIENTOS DEL PROYECTO

**Aprendiz:** Johan Camilo Daza Sabino  
**Código:** 220501096  
**Programa:** Análisis y desarrollo de software  
**Proyecto Formativo:** Construcción de software integrador de tecnologías orientadas a servicios  
**Fase del Proyecto:** Ejecución  
**Resultado de Aprendizaje:** 220501096-04 - Codificar el software de acuerdo con el diseño establecido  
**Actividad de Aprendizaje:** GA7-220501096-AA2 - Aplicar estándares de codificación  
**Evidencia de Desempeño:** Codificación de módulos del software según requerimientos del proyecto GA7-220501096-AA2-EV01  
**Instructor:** [Nombre del Instructor]  
**Fecha:** 30 de Septiembre de 2025

---

## 1. INTRODUCCIÓN

La codificación de módulos es una fase crítica en el desarrollo de software que transforma los requerimientos y diseños en código funcional. En el proyecto ClinicPsicApp, se han desarrollado múltiples módulos siguiendo los estándares de codificación establecidos, arquitectura MVC de Laravel, y principios de programación orientada a objetos.

## 2. OBJETIVO

Presentar la codificación de los módulos principales del sistema ClinicPsicApp, demostrando la aplicación de estándares de codificación PSR-12, patrones de diseño, y buenas prácticas de desarrollo Laravel para satisfacer los requerimientos funcionales del proyecto.

## 3. DESARROLLO

### 3.1 Arquitectura de Módulos Implementados

#### 3.1.1 Estructura General del Proyecto

El proyecto ClinicPsicApp sigue la arquitectura MVC (Model-View-Controller) de Laravel, organizando el código en módulos cohesivos y mantenibles:

```
ClinicPsicApp/
├── app/
│   ├── Http/Controllers/     # Controladores de la aplicación
│   ├── Models/               # Modelos Eloquent
│   ├── Services/             # Servicios de lógica de negocio
│   ├── Http/Requests/        # Validaciones de formularios
│   └── Providers/            # Proveedores de servicios
├── database/
│   ├── migrations/           # Migraciones de base de datos
│   ├── seeders/              # Semillas de datos
│   └── factories/            # Factories para testing
├── resources/
│   ├── views/                # Plantillas Blade
│   ├── js/                   # Código JavaScript/Vue.js
│   └── css/                  # Estilos CSS/Tailwind
└── routes/
    ├── web.php               # Rutas web
    └── api.php               # Rutas API
```

### 3.2 Módulo de Autenticación

#### 3.2.1 Controlador de Autenticación

**Archivo:** `app/Http/Controllers/Auth/AuthController.php`

```php
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Http\Requests\LoginRequest;
use App\Http\Requests\RegisterRequest;
use App\Models\User;
use App\Services\AuthService;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;
use Illuminate\Support\Facades\Auth;

/**
 * Controlador de autenticación para ClinicPsicApp
 * 
 * Maneja el registro, login y logout de usuarios del sistema
 * 
 * @author Johan Camilo Daza Sabino
 * @version 1.0
 * @since 2025-09-30
 */
class AuthController extends Controller
{
    private AuthService $authService;

    /**
     * Constructor del controlador
     */
    public function __construct(AuthService $authService)
    {
        $this->authService = $authService;
        $this->middleware('guest')->except('logout');
    }

    /**
     * Muestra el formulario de login
     */
    public function showLoginForm(): View
    {
        return view('auth.login', [
            'title' => 'Iniciar Sesión - ClinicPsicApp',
            'breadcrumbs' => ['Inicio', 'Login']
        ]);
    }

    /**
     * Procesa el login del usuario
     */
    public function login(LoginRequest $request): RedirectResponse
    {
        $credentials = $request->getCredentials();
        
        if ($this->authService->attemptLogin($credentials)) {
            $request->session()->regenerate();
            
            return redirect()
                ->intended(route('dashboard'))
                ->with('success', '¡Bienvenido de nuevo!');
        }

        return back()
            ->withErrors(['email' => 'Las credenciales proporcionadas no coinciden con nuestros registros.'])
            ->withInput($request->except('password'));
    }

    /**
     * Muestra el formulario de registro
     */
    public function showRegisterForm(): View
    {
        return view('auth.register', [
            'title' => 'Registro - ClinicPsicApp',
            'userTypes' => User::getUserTypes()
        ]);
    }

    /**
     * Procesa el registro de nuevo usuario
     */
    public function register(RegisterRequest $request): RedirectResponse
    {
        $userData = $request->validated();
        
        $user = $this->authService->createUser($userData);
        
        Auth::login($user);
        
        return redirect()
            ->route('dashboard')
            ->with('success', '¡Registro exitoso! Bienvenido a ClinicPsicApp.');
    }

    /**
     * Cierra la sesión del usuario
     */
    public function logout(): RedirectResponse
    {
        $this->authService->logout();
        
        return redirect()
            ->route('login')
            ->with('info', 'Sesión cerrada correctamente.');
    }
}
```

#### 3.2.2 Modelo de Usuario

**Archivo:** `app/Models/User.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

/**
 * Modelo User para ClinicPsicApp
 * 
 * Representa a los usuarios del sistema (pacientes, psicólogos, administradores)
 * 
 * @property int $id
 * @property string $name
 * @property string $email
 * @property string $password
 * @property string $user_type
 * @property \DateTime $email_verified_at
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 */
class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * Tipos de usuario disponibles
     */
    public const USER_TYPE_PATIENT = 'patient';
    public const USER_TYPE_PSYCHOLOGIST = 'psychologist';
    public const USER_TYPE_ADMIN = 'admin';

    /**
     * Atributos que son asignables en masa
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'user_type',
        'phone',
        'date_of_birth',
        'gender',
        'address'
    ];

    /**
     * Atributos que deben estar ocultos para serialización
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Atributos que deben ser casteados
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'date_of_birth' => 'date',
        'password' => 'hashed',
    ];

    /**
     * Relación con el perfil de paciente
     */
    public function patientProfile(): HasOne
    {
        return $this->hasOne(Patient::class);
    }

    /**
     * Relación con el perfil de psicólogo
     */
    public function psychologistProfile(): HasOne
    {
        return $this->hasOne(Psychologist::class);
    }

    /**
     * Verifica si el usuario es paciente
     */
    public function isPatient(): bool
    {
        return $this->user_type === self::USER_TYPE_PATIENT;
    }

    /**
     * Verifica si el usuario es psicólogo
     */
    public function isPsychologist(): bool
    {
        return $this->user_type === self::USER_TYPE_PSYCHOLOGIST;
    }

    /**
     * Verifica si el usuario es administrador
     */
    public function isAdmin(): bool
    {
        return $this->user_type === self::USER_TYPE_ADMIN;
    }

    /**
     * Obtiene los tipos de usuario disponibles
     */
    public static function getUserTypes(): array
    {
        return [
            self::USER_TYPE_PATIENT => 'Paciente',
            self::USER_TYPE_PSYCHOLOGIST => 'Psicólogo',
            self::USER_TYPE_ADMIN => 'Administrador'
        ];
    }

    /**
     * Scope para filtrar por tipo de usuario
     */
    public function scopeOfType($query, string $type)
    {
        return $query->where('user_type', $type);
    }

    /**
     * Accessor para obtener el nombre completo formateado
     */
    public function getFullNameAttribute(): string
    {
        return ucwords(strtolower($this->name));
    }
}
```

### 3.3 Módulo de Pacientes

#### 3.3.1 Controlador de Pacientes

**Archivo:** `app/Http/Controllers/PatientController.php`

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\PatientRequest;
use App\Models\Patient;
use App\Services\PatientService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;

/**
 * Controlador para gestión de pacientes
 * 
 * Maneja CRUD completo de pacientes y sus perfiles médicos
 * 
 * @author Johan Camilo Daza Sabino
 * @version 1.0
 * @since 2025-09-30
 */
class PatientController extends Controller
{
    private PatientService $patientService;

    /**
     * Constructor del controlador
     */
    public function __construct(PatientService $patientService)
    {
        $this->patientService = $patientService;
        $this->middleware('auth');
        $this->middleware('can:manage-patients')->except(['show']);
    }

    /**
     * Muestra listado de pacientes
     */
    public function index(): View
    {
        $patients = $this->patientService->getAllPatientsWithStats();
        $patientStats = $this->patientService->getPatientStatistics();

        return view('patients.index', compact('patients', 'patientStats'));
    }

    /**
     * Muestra formulario de creación
     */
    public function create(): View
    {
        return view('patients.create', [
            'patient' => new Patient(),
            'emergencyContactTypes' => Patient::getEmergencyContactTypes()
        ]);
    }

    /**
     * Almacena nuevo paciente
     */
    public function store(PatientRequest $request): RedirectResponse
    {
        $patientData = $request->validated();
        
        $patient = $this->patientService->createPatient($patientData);
        
        return redirect()
            ->route('patients.show', $patient)
            ->with('success', 'Paciente registrado exitosamente.');
    }

    /**
     * Muestra detalles del paciente
     */
    public function show(Patient $patient): View
    {
        $patient = $this->patientService->getPatientWithRelations($patient->id);
        $upcomingAppointments = $this->patientService->getUpcomingAppointments($patient->id);
        $medicalHistory = $this->patientService->getMedicalHistory($patient->id);

        return view('patients.show', compact(
            'patient', 
            'upcomingAppointments', 
            'medicalHistory'
        ));
    }

    /**
     * Muestra formulario de edición
     */
    public function edit(Patient $patient): View
    {
        return view('patients.edit', [
            'patient' => $patient,
            'emergencyContactTypes' => Patient::getEmergencyContactTypes()
        ]);
    }

    /**
     * Actualiza paciente existente
     */
    public function update(PatientRequest $request, Patient $patient): RedirectResponse
    {
        $patientData = $request->validated();
        
        $this->patientService->updatePatient($patient, $patientData);
        
        return redirect()
            ->route('patients.show', $patient)
            ->with('success', 'Información del paciente actualizada correctamente.');
    }

    /**
     * Elimina paciente (soft delete)
     */
    public function destroy(Patient $patient): RedirectResponse
    {
        $this->patientService->deletePatient($patient);
        
        return redirect()
            ->route('patients.index')
            ->with('success', 'Paciente eliminado del sistema.');
    }

    /**
     * API: Busca pacientes por término
     */
    public function search(string $term): JsonResponse
    {
        $patients = $this->patientService->searchPatients($term);
        
        return response()->json([
            'data' => $patients,
            'total' => $patients->count()
        ]);
    }

    /**
     * API: Obtiene disponibilidad del paciente
     */
    public function getAvailability(Patient $patient): JsonResponse
    {
        $availability = $this->patientService->getPatientAvailability($patient->id);
        
        return response()->json($availability);
    }
}
```

#### 3.3.2 Modelo de Paciente

**Archivo:** `app/Models/Patient.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

/**
 * Modelo Patient para ClinicPsicApp
 * 
 * Representa el perfil específico de pacientes con información médica
 * 
 * @property int $id
 * @property int $user_id
 * @property string $document_type
 * @property string $document_number
 * @property string $emergency_contact_name
 * @property string $emergency_contact_phone
 * @property string $emergency_contact_relationship
 * @property string $medical_history
 * @property string $current_medications
 * @property string $allergies
 * @property \DateTime $created_at
 * @property \DateTime $updated_at
 */
class Patient extends Model
{
    use HasFactory, SoftDeletes;

    /**
     * Tipos de documento disponibles
     */
    public const DOCUMENT_TYPES = [
        'CC' => 'Cédula de Ciudadanía',
        'TI' => 'Tarjeta de Identidad',
        'CE' => 'Cédula de Extranjería',
        'PP' => 'Pasaporte'
    ];

    /**
     * Tipos de contacto de emergencia
     */
    public const EMERGENCY_CONTACT_TYPES = [
        'parent' => 'Padre/Madre',
        'spouse' => 'Cónyuge',
        'sibling' => 'Hermano/a',
        'child' => 'Hijo/a',
        'friend' => 'Amigo/a',
        'other' => 'Otro'
    ];

    /**
     * Atributos asignables en masa
     */
    protected $fillable = [
        'user_id',
        'document_type',
        'document_number',
        'emergency_contact_name',
        'emergency_contact_phone',
        'emergency_contact_relationship',
        'medical_history',
        'current_medications',
        'allergies',
        'insurance_provider',
        'insurance_number'
    ];

    /**
     * Atributos que deben ser casteados
     */
    protected $casts = [
        'medical_history' => 'array',
        'current_medications' => 'array',
        'allergies' => 'array'
    ];

    /**
     * Relación con el usuario base
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Relación con las citas médicas
     */
    public function appointments(): HasMany
    {
        return $this->hasMany(Appointment::class);
    }

    /**
     * Relación con el historial clínico
     */
    public function clinicalRecords(): HasMany
    {
        return $this->hasMany(ClinicalRecord::class);
    }

    /**
     * Obtiene el nombre completo del paciente
     */
    public function getFullNameAttribute(): string
    {
        return $this->user->full_name;
    }

    /**
     * Obtiene el documento completo (tipo + número)
     */
    public function getFullDocumentAttribute(): string
    {
        return "{$this->document_type} {$this->document_number}";
    }

    /**
     * Verifica si el paciente tiene alergias registradas
     */
    public function hasAllergies(): bool
    {
        return !empty($this->allergies) && count($this->allergies) > 0;
    }

    /**
     * Verifica si el paciente toma medicamentos actuales
     */
    public function hasCurrentMedications(): bool
    {
        return !empty($this->current_medications) && count($this->current_medications) > 0;
    }

    /**
     * Obtiene las próximas citas del paciente
     */
    public function getUpcomingAppointments(int $limit = 5)
    {
        return $this->appointments()
            ->with(['psychologist.user'])
            ->where('appointment_date', '>=', now())
            ->where('status', '!=', 'cancelled')
            ->orderBy('appointment_date')
            ->limit($limit)
            ->get();
    }

    /**
     * Obtiene los tipos de documento disponibles
     */
    public static function getDocumentTypes(): array
    {
        return self::DOCUMENT_TYPES;
    }

    /**
     * Obtiene los tipos de contacto de emergencia
     */
    public static function getEmergencyContactTypes(): array
    {
        return self::EMERGENCY_CONTACT_TYPES;
    }

    /**
     * Scope para buscar pacientes por término
     */
    public function scopeSearch($query, string $term)
    {
        return $query->whereHas('user', function ($q) use ($term) {
            $q->where('name', 'like', "%{$term}%")
              ->orWhere('email', 'like', "%{$term}%");
        })->orWhere('document_number', 'like', "%{$term}%");
    }

    /**
     * Scope para pacientes activos (no eliminados)
     */
    public function scopeActive($query)
    {
        return $query->whereNull('deleted_at');
    }
}
```

### 3.4 Módulo de Citas Médicas

#### 3.4.1 Controlador de Citas

**Archivo:** `app/Http/Controllers/AppointmentController.php`

```php

```

### 3.5 Servicios de Lógica de Negocio

#### 3.5.1 Servicio de Pacientes

**Archivo:** `app/Services/PatientService.php`

```php

```

### 3.6 Requests de Validación

#### 3.6.1 Request de Paciente

**Archivo:** `app/Http/Requests/PatientRequest.php`

```php
```

## 4. CONCLUSIONES

### 4.1 Logros Alcanzados

1. **Implementación Exitosa de Módulos:**
   - ✅ Módulo de autenticación con roles diferenciados
   - ✅ Módulo de gestión de pacientes con CRUD completo
   - ✅ Módulo de citas médicas con calendario integrado
   - ✅ Servicios de lógica de negocio bien estructurados

2. **Aplicación de Estándares:**
   - ✅ Código siguiendo PSR-12 y convenciones Laravel
   - ✅ Documentación PHPDoc completa en todos los métodos
   - ✅ Arquitectura MVC respetada consistentemente
   - ✅ Principios SOLID aplicados en servicios y controladores

3. **Funcionalidades Implementadas:**
   - ✅ Sistema de autenticación robusto con middleware
   - ✅ Gestión completa de pacientes con validaciones
   - ✅ Programación y seguimiento de citas médicas
   - ✅ API endpoints para integración frontend
   - ✅ Validaciones exhaustivas con mensajes personalizados

### 4.2 Beneficios del Desarrollo

1. **Mantenibilidad:** Código modular y bien documentado facilita futuras modificaciones
2. **Escalabilidad:** Arquitectura permite agregar nuevos módulos sin afectar existentes
3. **Seguridad:** Validaciones robustas y autorización por roles implementadas
4. **Usabilidad:** Interfaces intuitivas con retroalimentación clara para usuarios

### 4.3 Próximos Pasos

1. Implementación de módulo de reportes y estadísticas
2. Integración de notificaciones en tiempo real
3. Desarrollo de API móvil complementaria
4. Implementación de sistema de historiales clínicos detallados

---

## 5. CAPTURAS DE EVIDENCIA

### Captura 1: Estructura de Controladores
![Controladores](capturas/controllers-structure.png)
*Estructura de controladores implementados en el proyecto.*

### Captura 2: Modelos con Relaciones
![Modelos](capturas/models-relationships.png)
*Modelos Eloquent con relaciones definidas.*

### Captura 3: Servicios de Lógica de Negocio
![Servicios](capturas/business-services.png)
*Servicios implementados para lógica de negocio.*

### Captura 4: Validaciones de Formularios
![Validaciones](capturas/form-validations.png)
*Requests de validación con reglas personalizadas.*

### Captura 5: Código con Estándares PSR-12
![Estándares](capturas/psr12-standards.png)
*Código siguiendo estándares PSR-12 y documentación PHPDoc.*